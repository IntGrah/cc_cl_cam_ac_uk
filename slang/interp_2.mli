(* Using Int_map to represent memory *)

type value
and closure = code * env

and instruction =
  | PUSH of value
  | LOOKUP of Ast.var
  | UNARY of Ast.Unary_op.t
  | OPER of Ast.Binary_op.t
  | ASSIGN
  | SWAP
  | POP
  | BIND of Ast.var
  | FST
  | SND
  | DEREF
  | APPLY
  | MK_PAIR
  | MK_INL
  | MK_INR
  | MK_REF
  | MK_CLOSURE of code
  | MK_REC of Ast.var * code
  | TEST of code * code
  | CASE of code * code
  | WHILE of code * code

and code = instruction list
and binding = Ast.var * value
and env = binding list

type env_or_value = EV of env | V of value
type env_value_stack = env_or_value list
type state = code * env_value_stack * value Heap.t

val step : state -> state
val compile : Ast.t -> code
val interpret : Ast.t -> value
val pp_instruction : Format.formatter -> instruction -> unit
val pp_value : Format.formatter -> value -> unit
val pp_env_or_value : Format.formatter -> env_or_value -> unit
val pp_code : Format.formatter -> code -> unit
